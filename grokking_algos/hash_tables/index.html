<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `hash_tables` mod in crate `grokking_algos`."><meta name="keywords" content="rust, rustlang, rust-lang, hash_tables"><title>grokking_algos::hash_tables - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../grokking_algos/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Module hash_tables</p><div class="sidebar-elems"><p class="location"><a href="../index.html">grokking_algos</a></p><div id="sidebar-vars" data-name="hash_tables" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">grokking_algos</a>::<wbr><a class="mod" href="">hash_tables</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/grokking_algos/hash_tables/mod.rs.html#1-305" title="goto source code">[src]</a></span></h1><div class="docblock"><p>Hash Tables</p>
<p><code>hash_tables</code> is a module that introduces hash tables - a useful and basic data structure.
Central to the exploration of the structure</p>
<h1 id="applications" class="section-header"><a href="#applications">Applications</a></h1>
<ul>
<li>Associative arrays (arrays whose indices are arbitrary strings or other objects - a <code>dictionary</code> in Python, for example)</li>
<li>Database indexing (also used in disk-based data structures)</li>
<li>Caches (data tables used to speed up data access)</li>
<li>Object representation (Python, JavaScript and Ruby use hash tables to implement objects)</li>
</ul>
<h1 id="hash-functions" class="section-header"><a href="#hash-functions">Hash Functions</a></h1>
<p>At the core of the hash table is the hash function. At its simplest, a hash function is any function that maps
'data of arbitrary size to fixed-size values' - in other words, quite often a mapping of strings to numbers.
These mappings are both consistent (so as to retain like values for like data, ex. 'Van Gogh' is always mapped to '4') and provide
some guarantee of uniqueness (so as to map different values to different data, 'Van Gogh' mapping to '4' is fundamentally different than 'Renoir' to '5').</p>
<p>For most of us, we are interacting with hash functions any time we operate a computer. These functions, while
sharing the aforementioned properties described above, share another trait: they are not functions that almost any
of us will have to (nor should) attempt to implement ourselves. The development of a good hash function (algorithms themselves!)
is the work of cryptographers - work that is vetted by a community of engineers and transparent in its logic
to any who care to ask, because our mutual benefit in using proven and secure hashes greatly outweighs the risks to us all
should one implement a bad hash function (i.e., one with high collison rate, etc).</p>
<p>For a great overview of hash functions, see: <a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-107r1.pdf">NIST Special Publication 800-107, Revision 1 - Recommendation for Applications Using Approved Hash Algorithms</a></p>
<h1 id="construction" class="section-header"><a href="#construction">Construction</a></h1>
<p>Let's start with a simple array structure:</p>
<pre><code class="language-text">[ ][ ][ ][ ][ ]

 0  1  2  3  4
</code></pre>
<p>Our hash table values will occupy indicies within the array after having first passed
through a hashing process. Let's walk through the steps:</p>
<p>We'll imagine that we storing an arbitrary collection of named entities and some associated
set of scalar values for each (ex. 'foo' =&gt; 1, 'bar' =&gt; 2). The datatypes are arbitrary and
we could also store strings, array, other maps, etc.</p>
<p>Initially, we want to store <code>foo</code>, so we provide <code>foo</code> to a hashing function whose return value
will provide us with the index we should use to store our value of <code>1</code>. Our hash function
takes in <code>foo</code> and returns an index of <code>3</code> - in turn, we store <code>1</code> at index <code>3</code>.</p>
<pre><code class="language-text">[ ][ ][ ][1][ ]

 0  1  2  3  4
</code></pre>
<p>Next, we want to store <code>bar</code> - it too passes through our hashing function at which point we
receive a return value of <code>0</code>. So, again, we store our value <code>2</code> at the index provided to us.</p>
<pre><code class="language-text">[2][ ][ ][1][ ]

 0  1  2  3  4
</code></pre>
<p>This process repeats until all values have been stored:</p>
<pre><code class="language-text">[2][4][3][1][5]

 0  1  2  3  4
</code></pre>
<p>But - how do we get items out of the hash array? We don't have to search for it iteratively.
Instead, we can simply ask 'please fetch me value <code>foo</code>'.</p>
<pre><code class="language-text">            ____________________

            |                  |
 `foo` ===&gt; |   hash function  | ===&gt; 3 (index)
            |                  |
            ____________________
</code></pre>
<p>That's right - we simply pass the value requested back to the hash function! The hash function
will return the same value it provided when we leveraged it prior to storage. This, again, is
a byproduct of good hash functions, we can call this as many times as necessary and we can be
sure that our return value for a given input will be identical.</p>
<p>Using the return value, we can perform the lookup in <code>O(1)</code> time - very efficient!</p>
<h1 id="hash-tables-in-rust" class="section-header"><a href="#hash-tables-in-rust">Hash Tables in Rust</a></h1>
<p>In Rust, hash tables are called hash maps and are provided by the <code>std::collections</code> module.</p>
<p>We can instantiate from an emtpy map:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">things</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">things</span>.<span class="ident">insert</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>);
<span class="ident">things</span>.<span class="ident">insert</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">2</span>);
<span class="ident">things</span>.<span class="ident">insert</span>(<span class="string">&quot;baz&quot;</span>, <span class="number">3</span>);</pre></div>
<p>Or even from another data structure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="ident">things</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> [(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;bar&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;baz&quot;</span>, <span class="number">3</span>)]
    .<span class="ident">iter</span>().<span class="ident">cloned</span>().<span class="ident">collect</span>();</pre></div>
<p>We can fetch values and return them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="ident">things</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> [(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;bar&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;baz&quot;</span>, <span class="number">3</span>)]
    .<span class="ident">iter</span>().<span class="ident">cloned</span>().<span class="ident">collect</span>();

<span class="kw">if</span> <span class="op">!</span><span class="ident">things</span>.<span class="ident">contains_key</span>(<span class="string">&quot;banana&quot;</span>) {
   <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Found {} things, but no &#39;banana&#39;&quot;</span>, <span class="ident">things</span>.<span class="ident">len</span>());
}

<span class="ident">things</span>.<span class="ident">remove</span>(<span class="string">&quot;baz&quot;</span>);

<span class="kw">let</span> <span class="ident">to_find</span> <span class="op">=</span> [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>];
<span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">thing</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">to_find</span> {
    <span class="kw">match</span> <span class="ident">things</span>.<span class="ident">get</span>(<span class="ident">thing</span>) {
        <span class="prelude-val">Some</span>(<span class="ident">found</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}: {}&quot;</span>, <span class="ident">thing</span>, <span class="ident">found</span>),
        <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} is not found.&quot;</span>, <span class="ident">thing</span>)
    }
}
</pre></div>
<h1 id="exercises" class="section-header"><a href="#exercises">Exercises</a></h1>
<p>Which of these hash function are consistent?</p>
<p>5.1</p>
<p>f(x) = 1</p>
<p>A - 5.1</p>
<p>True</p>
<hr />
<p>5.2</p>
<p>f(x) = rand()</p>
<p>A - 5.2</p>
<p>False</p>
<hr />
<p>5.3</p>
<p>f(x) = next_empty_slot()</p>
<p>A - 5.3</p>
<p>False</p>
<hr />
<p>5.4</p>
<p>f(x) = len(x)</p>
<p>A - 5.4</p>
<p>True</p>
<h1 id="use-cases-in-detail" class="section-header"><a href="#use-cases-in-detail">Use Cases In Detail</a></h1><h2 id="lookups" class="section-header"><a href="#lookups">Lookups</a></h2>
<p>Let's imagine that we want to model a phone book - a simple mapping of name to number.</p>
<p>We need to be able to add a name and associated number, as well as be able to enter a name
and retrieve their associated number.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">phone_book</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">phone_book</span>.<span class="ident">insert</span>(<span class="string">&quot;John&quot;</span>, <span class="number">4283058824</span>);
<span class="ident">phone_book</span>.<span class="ident">insert</span>(<span class="string">&quot;Ringo&quot;</span>, <span class="number">2123134152</span>);
<span class="ident">phone_book</span>.<span class="ident">insert</span>(<span class="string">&quot;George&quot;</span>, <span class="number">3039956721</span>);</pre></div>
<p>We can also think of DNS resolution in similar terms:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dns_store</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">dns_store</span>.<span class="ident">insert</span>(<span class="string">&quot;google.com&quot;</span>, <span class="number">33.125</span>.<span class="number">458.425</span>);
<span class="ident">dns_store</span>.<span class="ident">insert</span>(<span class="string">&quot;facebook.com&quot;</span>, <span class="number">852.285</span>.<span class="number">284.4</span>);
<span class="ident">dns_store</span>.<span class="ident">insert</span>(<span class="string">&quot;microsoft.com&quot;</span>, <span class="number">12.123</span>.<span class="number">12.123</span>);</pre></div>
<h2 id="uniqueness" class="section-header"><a href="#uniqueness">Uniqueness</a></h2>
<p>There are many times that we face the need to restrict and/or optimize actions against or access to data.</p>
<p>We want to build on our phonebook case, ensuring that only a single person with a name is inserted
into the hash table. This process might look generally like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
                                [ <span class="ident">Request</span> <span class="ident">Made</span> <span class="ident">To</span> <span class="ident">Insert</span> <span class="ident">Data</span> ]
                                               <span class="op">|</span>
                       [ <span class="ident">Check</span> <span class="ident">If</span> <span class="ident">This</span> <span class="ident">Data</span> <span class="ident">Is</span> <span class="ident">Already</span> <span class="ident">In</span> <span class="ident">The</span> <span class="ident">Hash</span> <span class="ident">Table</span> ]
                             <span class="op">/</span>                                \
               [ <span class="ident">YES</span>: <span class="ident">Deny</span> <span class="ident">Insert</span> ]                    [ <span class="ident">NO</span>: <span class="ident">Allow</span> <span class="ident">Insert</span> ]
                                                                \
                                                          [ <span class="ident">Add</span> <span class="ident">To</span> <span class="ident">Hash</span> <span class="ident">Table</span> ]</pre></div>
<p>If we had been storing these pairs in a simple list, we would face a point where
this request to insert data would be unbearably slow, as we'd be performing
a simple linear search.</p>
<p>See: <a href="../intro_to_algos/fn.linear_search.html">linear_search</a></p>
<h2 id="collisons" class="section-header"><a href="#collisons">Collisons</a></h2>
<p>When we spoke about what would constitute a bad hash function, one of the defining characteristics
was that it would have high collision rates.</p>
<p>How do we avoid this possibility?</p>
<p>There are two main factors: a robust hash function and a low load factor.</p>
<p>Load factor is new to our discussion, but it's simple to grok as it represents:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
                 <span class="ident">number</span> <span class="ident">of</span> <span class="ident">items</span> <span class="kw">in</span> <span class="ident">hash</span> <span class="ident">table</span>
                 <span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span><span class="op">-</span>
                    <span class="ident">total</span> <span class="ident">number</span> <span class="ident">of</span> <span class="ident">slots</span></pre></div>
<p>We have already spoken about the construction of hash tables, namely their reliance on arrays for storage.
So, looking at the above formula for load factor it's really nothing more than &quot;the count of elements in the array
over the length of the array&quot;. If we need to store 100 items in our hash table, and we have 100 slots - our load factor
is 1. If we have only 50 slots for 100 items, our load factor is doubled - it's 2! We don't have enough slots for the
items we intend to store. If we have a load factor greater than 1, we will need to resize our hash table to avoid
collisions. However - resizing is a cost that we should be mindful of, it's expensive and we should aim to minimize
the need to do so.</p>
<p>The second key to low collision rates we said was a good hash function - in essence, the quality of this function
depends in part on its ability to evenly distribute values within the array storage. SHA (Secure Hash Algorithm)
functions, in particular, are often safe bets. Just be sure to use the latest recommended SHA function(s) to ensure
safe cryptographic hashing!</p>
<h1 id="exercises-1" class="section-header"><a href="#exercises-1">Exercises</a></h1>
<p>Suppose you have these four hash functions that work with strings:</p>
<p>A. Return '1' for all input</p>
<p>B. Use the length of the string as the index</p>
<p>C: Use the first character of the string as the index. So, all strings starting with 'a' are hashed
together, and so on.</p>
<p>D: Map every letter to a prime number: a = 2, b = 3, c = 5, d = 7, e = 11, and so on. For a string,
the hash function is the sum of all the characters modulo the size of the hash. For example,
if your hash size is 10, and the string is &quot;bag&quot;, the index is 3 + 2 + 17 % 10 = 22 % 10 = 2.</p>
<p>For each of these examples, which hash functions would provide a good distribution? Assume a hash table
size of 10 slots.</p>
<p>5.5</p>
<p>A phonebook where the keys are names and values are phone numbers. The names are as follows:
Esther, Ben, Bob and Dan.</p>
<p>A - 5.5</p>
<p>C + D</p>
<hr />
<p>5.6</p>
<p>A mapping from battery size to power. The sizes are A, AA, AAA, and AAAA.</p>
<p>A - 5.6</p>
<p>B + D</p>
<hr />
<p>5.7</p>
<p>A mapping from book titles to authors. The titles are: Maus, Fun Home, and Watchmen.</p>
<p>A - 5.7</p>
<p>B + C + D</p>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="grokking_algos"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>